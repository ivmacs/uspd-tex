\section{Общие сведения о программе}

\subsection{Назначение Т--системы}
Т--система~---  среда программирования с поддержкой автоматического динамического
распараллеливания программ. Для реализации концепции автоматического динамического
распараллеливания программ в Т--системе предложена новая модель организации
вычислительного процесса, основанная на следующих базовых принципах:
\begin{itemize}
\item
\end{itemize}

\subsection{Некоторые моменты из теории функционального программирования}
Теорема Чёрча--Россера.
Если $R$~--- отношение, то пусть $\bar{R}$ означает его конечно--транзитивное замыкание.
\dots

Теорема о единственности нормальной формы (следствие из т.~Ч--Р).
Любые две нормальные формы лямбда-выражения алфавитно-эквивалентны.

Ромбическое свойство.
Если выражение $E$ может быть редуцировано к двум выражениям $E_1$ и $E_2$, то существует
$N$, в которое могут быть редуцированы $E_1$ и $E_2$.

Теорема стандартизации.
Если выражение $E$ имеет нормальную форму,
то редукция самого левого из самых внешних редексов на каждом
этапе редукции $E$ гарантирует достижение этой нормальной
формы с точностью до алфавитной эквивалентности.

\subsection{Параллельная редукция графов}
Ниже изложена краткая теоретическая база параллельной редукции графов.
$\lambda$--исчисление~--- это исчисление анонимных (безымянных) функций.
Оно даёт, во--первых, метод представления функций и,
во--вторых, множество правил вывода для синтаксического преобразования функций.

Редукция~--- это процесс упрощения $\lambda$--выражения:
\begin{itemize}
\item $\alpha$--редукция заключается в переименовании свободных переменных;
\item $\beta$--редукция~---  это процесс копирования тела абстракции
с заменой всех вхождений связанной переменной на выражение аргумента;
\item $\delta$--редукция~---  это способ преобразования цепочек символов,
являющихся функциональными константами.
\end{itemize}

Редекс~--- это редуцируемое выражение, $\lambda$--выражения могут
быть представлены в виде графов. При этом множественные ссылки
на одно и то же выражение аргумента представляются множеством
дуг, идущих к единственной разделяемой копии соответствующего
графа аргумента.

При редукции графа выражения вполне возможно присутствие в этом
графе множества редексов в любой момент. Вследствие прозрачности
ссылок эти редексы будут всегда вычисляться с одинаковым результатом
независимо от того, где и когда это вычисление имеет место. Поэтому
вполне возможно вычислять их одновременно, разместив на отдельных
процессорах. Каждый процессор может затем приступить к редукции
соответствующих редексов, возможно генерируя новые процессы и,
таким образом, создавая новые параллельные задачи. Ниже приведён
алгоритм (весьма упрощенный), реализующий параллельную редукцию
графов на языке Лисп:
\begin{verbatim}
;; Graph node definition
(defstruct (n)
           (in)
           (out)
           (fun) (val)
           (thread)
           (ct) (dt))

;; Main functions
(defun getfor (n)
              (add-link *node* n)
              (que-put n *cal*))
(defun forget (n)
              (del-link *node* n)
              (que-put n *col*))
(defun cal (n)
           (or (null (n-out n))
               (n-thread n)
               (setf (n-thread n) (start-thread n))))
(defun col (n)
           (or (n-out n)
               (null (n-thread n))
               (setf (n-thread n) (kill-thread n))))
(defun start (n)
             (call-with-node n
                             (compute n))
             (if (n-ct n) (funcall (n-ct n) n))
             (mapcar +'kill-thread (n-out n)))
(defun stop (n)
            (mapcar %'kill-thread (n-out n))
            (if (n-dt n) (funcall (n-dt n) n))
            (call-with-node n
                            (mapcar #'forget (n-in n))))
(provide 'magnate)
	
\end{verbatim}

\subsection{Расширения классической схемы}
\begin{itemize}
\item Редукция графов~--- меняет граф, не меняет его значение.
\item Стратегия вычислений~--- решает, что вычислять в первую очередь.
\item Распределение работы~--- решает, какую задачу кому отдать.
\end{itemize}

\subsection{Вызов по состоянию}
Результатом работы функции может быть некоторая фиктивная величина,
которая означает, что над глобальными данными произведено некоторое
преобразование.

\subsection{Мемоизация}
Для чистых функций (не имеющих побочных эффектов) можно
запоминать результат их вычислений и затем при повторных
вызовах от одних и тех же аргументов просто брать значение из таблицы.

\subsection{Библиотека классов C++ и интерфейс с другими языками}
В качестве средства реализации ядра Т-системы выбран язык
C++.  Это обеспечивает хорошую эффективность и переносимость кода,
а также упрощает достижение таких важных целей, как модульность
и расширяемость ПО. В ряде случаев (например, для многих
не вычислительных задач), использование C++
также очень желательно и с точки зрения удобства разработки
параллельных приложений.

Интерфейс Т-системы для разработчика ПО, программирующего на языке
C++, выглядит как совокупность классов, которые он может гармонично
включить в дизайн своего приложения и эффективно использовать
все возможности Т-системы на всех уровнях распараллеливания,
начиная от динамического распределения вычислительной нагрузки
и заканчивая интерфейсами с клиентской стороной.

\subsection{Гладкие Т--расширения языков C и Fortran}
Важным достоинством новой версии Т--системы является то,
что она поддерживает гладкое расширение языка С. Гладким
оно названо потому, что все необходимые конструкции для
указания мест распараллеливания программы просто и естественно
погружены в синтаксис языка С.

Компилятор преобразует программу на языке ТС в программу на языке С.
При этом он производит необходимый анализ программы и вставляет в текст
все необходимые обращения к ядру Т--системы. Затем С--программа
транслируется обычным оптимизирующим компилятором.

Ключевым свойством гладкого расширения языка является то,
что программа на этом языке превращается в программу на
языке С и без специального компилятора, если определить
ключевые слова, добавленные в язык ТС как макросы. Предполагается,
что это удобство будет оценено пользователями, которым будет проще
начинать разработку и переделку своих программ под Т--систему.
TFortran: первая версия будет на базе {\tt f2c} (Fortran--to--C конвертора).

\subsection{Среда для разработки, отладки и профилировки программ}
Среда разработки для Т-системы является надстройкой над средой
разработки обычных последовательных программ.

\subsection{Компилятор (source--to--source converter)}
text

\subsection{Отказоустойчивость}
text

\subsection{Язык программирования T++}
text

\subsection{Пример программы на языке T++}
text

\subsection{Структура программы на языке T++}
text

\subsection{Дополнительные ключевые слова языка Т++}
text

\subsection{Заголовочный файл {\tt<trt>}}
text

\subsection{Цикл разработки программ на языке Т++}
text

\subsection{Язык программирования Т++}
text


\section{Структура программы}

\subsection{Ядро параллельной редукции графов}
text

\subsection{Внешнее вычисление узлов графа}
text

\subsection{Распределенная мемо--таблица}
text

\subsection{Внешнее планирование}
text

\subsection{Дерево вычислительных ресурсов}
text

\subsection{Компилятор (source--to--source converter)}
text


\section{Проверка программы}

\subsection{Запуск приложения Т--системы}

text 

\subsection{Запуск и командные опции компилятора {\tt t++}}

text

\endinput
